<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>未来已来</title>
  <subtitle>行走天下，微观世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-08-11T05:32:26.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>此刻柳暗花明</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS10推送和通知新特性总结</title>
    <link href="http://yoursite.com/2017/08/11/iOS10%E6%8E%A8%E9%80%81%E5%92%8C%E9%80%9A%E7%9F%A5%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/08/11/iOS10推送和通知新特性总结/</id>
    <published>2017-08-11T05:17:29.000Z</published>
    <updated>2017-08-11T05:32:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言:</strong>此文章是对iOS10推送和通知新特性的一些总结，主要内容是一些需要注意的经验或技巧，对通知中具体的API没有进行很详细的介绍，所以阅读此文章需要先对iOS10的推送有一个基础的了解。<br><a id="more"></a></p>
<p>可以参考本文的参考链接，是两位大神对iOS10通知和推送进行的更详细的说明。</p>
<h2 id="新framework"><a href="#新framework" class="headerlink" title="新framework"></a>新framework</h2><p>针对推送和通知,iOS10引入了两个新的framework:</p>
<ol>
<li><p>UserNotifications.framework：用来注册和处理本地和远程通知,当通知到达用户的设备上时，Apps和app extensions 可以使用这个framework去接收和潜在的修改本地通知或远程通知。</p>
</li>
<li><p>UserNotificationsUI.framework：用来定制本地或远程通知出现在用户设备上时的外观。可以通过使用这个framework去定义一个app extension去接受通知的数据，然后提供一个与数据符合的可视化外观。当然这个app extension也能响应和这个通知结合的定制的响应动作。</p>
</li>
</ol>
<h2 id="新特性："><a href="#新特性：" class="headerlink" title="新特性："></a>新特性：</h2><ol>
<li><p>总体来说增加的新的实用的功能包括：撤回单条通知、更新已展示通知、中途修改通知内容、在通知中显示多媒体资源、自定义UI等。</p>
</li>
<li><p>iOS10以后，APNs可根据推送消息的唯一标示符查询某条消息是否被用户阅读，可更新某一推送消息，而不用发重读的多条消息。</p>
</li>
</ol>
<h2 id="推送字段说明："><a href="#推送字段说明：" class="headerlink" title="推送字段说明："></a>推送字段说明：</h2><ol>
<li>mutable-content:在推送中增加这个字段，决定了我们可以在service notification扩展中修改通知内容，也可以在content notification扩展中自定义通知界面。如果没有这个字段,我们新增的通知扩展不会生效。</li>
<li>category:是和后台商量好的一个值,不同的category可以显示不同的action,也就是通知下面的按钮或者输入框,可以扩展一些操作而不必进入程序。</li>
<li>apps-collapse-id:作为唯一标示，可以用来更新推送。</li>
<li>content-available:这个是在iOS7时引入的一个字段，如果开启了Background mode下的remote notification,并且推送的字段中包含此字段，只要用户不强制关掉App,App无论是在后台还是在前台，都可以回调下面的方法。<pre><code>- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(nonnull void (^)(UIBackgroundFetchResult))completionHandler</code></pre>

</li>
</ol>
<h2 id="经验技巧（tips）"><a href="#经验技巧（tips）" class="headerlink" title="经验技巧（tips）"></a>经验技巧（tips）</h2><ol>
<li>调用方法<pre><code>[[UIApplication sharedApplication] registerForRemoteNotifications];</code></pre>会触发调用下面两个方法之一<pre><code>- (void)application:(UIApplication <em>)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData </em>)deviceToken</code></pre><br><pre><code>- (void)application:(UIApplication <em>)application didFailToRegisterForRemoteNotificationsWithError:(NSError </em>)error</code></pre><br>也就是说，在真机环境下，哪怕用户还没有允许通知，或者设置了禁用推送，手机都是可以通过回调获取到deviceToken的。</li>
<li>iOS10中申请通知权限的代码如下:<pre><code>
UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];
     center.delegate = self;
     //        [center setNotificationCategories:nil];
     [center getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) {
         if (settings.authorizationStatus == UNAuthorizationStatusNotDetermined) {
             [center requestAuthorizationWithOptions:(UNAuthorizationOptionBadge | UNAuthorizationOptionSound | UNAuthorizationOptionAlert) completionHandler:^(BOOL granted, NSError * _Nullable error) {
                 if (granted && !error) {
                     NSLog(@"允许通知");
                 } else {
                     NSLog(@"拒绝通知");
                 }
             }];
         }
     }];
     //在用户允许通知之后，在真机中会再次回调获取到deviceToken的代理方法。
     </code></pre></li>
<li><p>iOS10之前，在（1）应用程序在前台时；（2）应用程序在后台，然后点击了推送进入应用程序时，两种情况下会回调方法<br><pre><code>- (void)application:(UIApplication <em>)application didReceiveRemoteNotification:(NSDictionary </em>)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler{<br> //下面简称“方法1”<br>}<br></code></pre><br>如果开启了后台推送模式,还会在第三种情况下（3）应用程序在后台时，调用此方法。</p>
<p> 从iOS10开始,新增了两个通知中心的代理方法来处理通知<br> <pre><code>- (void)userNotificationCenter:(UNUserNotificationCenter <em>)center willPresentNotification:(UNNotification </em>)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler {<br> //下面简称“方法2”<br> //此方法只有应用程序在前台时才会调用,通知展示之前调用<br> NSLog(@”应用程序在前台,即将展示推送”);<br> completionHandler(UNNotificationPresentationOptionBadge | UNNotificationPresentationOptionSound | UNNotificationPresentationOptionAlert);<br>}<br></code></pre><br><pre><code>- (void)userNotificationCenter:(UNUserNotificationCenter <em>)center didReceiveNotificationResponse:(UNNotificationResponse </em>)response withCompletionHandler:(void(^)())completionHandler {<br> //下面简称“方法3”<br> //用户对通知进行响应之后调用,各种响应都会调用此方法，可以根据参数response来判断用户的响应方式,是点击了通知，点击了按钮还是输入了内容等<br> NSLog(@”用户响应”);<br> completionHandler();<br>}<br></code></pre><br>如果实现了上述两个新增方法，当推送到达之后，调用的方法情况会发生变化，如下：</p>
<ul>
<li>应用程序在前台，会首先调用“方法1”,然后再调用方法2；</li>
<li>应用程序在后台，只调用“方法1”；</li>
<li>应用程序在后台，点击某一条推送，调用“方法3”；</li>
<li>应用程序在前台，点击某一条推送，调用“方法3”。</li>
</ul>
</li>
<li>使用了iOS10的新增方法之后，要想在推送到达之前或者应用程序在后台时执行一段代码，比如修改推送内容再提示用户，需要在项目中使用应用程序扩展Notification Service Extension来实现。</li>
<li>如果在项目中使用了应用程序扩展Notification Service Extension，在调试的过程中，如果想要打断点调试扩展的代码，需要在Xcode中运行扩展，然后再选择项目，才可以。（后面要说的另外一个扩展Notification Content Extension也是一样的道理）</li>
<li>iOS10的通知新特性可以让通知中包含附件,比如音频、图像或视频等内容,并且可以将其内容显示出来。使用本地通知时,可以在通知创建时,将附件加入即可。对于远程通知，则必须实现使用UNNotificationServiceExtension类通知服务扩展。</li>
<li>如果在项目中使用了应用程序扩展Notification Content Extension,如果想要看到效果，必须在扩展的info.plist文件中设置NSExtension-&gt;NSExtensionAttributes-&gt;UNNotificationExtensionCategory字段的内容，可以是字符串或者字符串数组，字符串代表的是categoryIdentifier，必须和通知内容中的categoryIdentifier保持一致才会有效果。</li>
<li>如果使用本地推送，触发器为位置信息时，一般使用CLRegion的子类CLCircularRegion类来定义位置信息。</li>
<li>附件类UNNotificationAttachment定义的options属性中的UNNotificationAttachmentOptionsThumbnailClippingRectKey,代表的是缩略图显示的图片范围。（这个键所对应的值是包含一个归一化的CGRect - 也就是说，一个单元的矩形，其值是在以1.0〜 0.0 ，表示要显示的原始图像的所述部分的字典。例如，原点为（0.25 ， 0.25）和大小为（0.5 ，0.5 ）定义了剪辑矩形，只显示图像的中心部分。使用CGRectCreateDictionaryRepresentation函数来创建字典的矩形。）</li>
<li>附件的路径并不一定需要时https的，只要打开Allow Arbitrary Loads后就可以使用http。</li>
<li><p>假如前面在Service Extension下载好了图片或者是视频，在自定义UI部分想要获取，就可以通过UNNotificationAttachment * attachment = notification.request.content.attachments.firstObject;查找附件来获取数据。但是必须注意，形成附件后，文件的实际存储被移到了pushStore的一个系统级别的缓存文件夹，此时需要调用NSURL在iOS8开始提供的两个方法来获取权限，提取数据。</p>
<blockquote>
<p><code>startAccessingSecurityScopedResource</code><br><code>stopAccessingSecurityScopedResource</code></p>
</blockquote>
</li>
</ol>
<pre><code>[attachment.URL startAccessingSecurityScopedResource];
        NSData * data = [NSData dataWithContentsOfFile:attachment.URL.path];
        [attachment.URL stopAccessingSecurityScopedResource];
        self.imageView.image = [UIImage imageWithData:data];
</code></pre>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol>
<li><a href="http://www.jianshu.com/p/9c9035212af0" target="_blank" rel="external">iOS10里的通知与推送</a></li>
<li><a href="http://www.jianshu.com/p/f5337e8f336d" target="_blank" rel="external">iOS10推送必看系列文章,总共四篇</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言:&lt;/strong&gt;此文章是对iOS10推送和通知新特性的一些总结，主要内容是一些需要注意的经验或技巧，对通知中具体的API没有进行很详细的介绍，所以阅读此文章需要先对iOS10的推送有一个基础的了解。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS,推送,通知" scheme="http://yoursite.com/tags/iOS-%E6%8E%A8%E9%80%81-%E9%80%9A%E7%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>iOS中制作Framework静态库</title>
    <link href="http://yoursite.com/2017/08/07/iOS%E4%B8%AD%E5%88%B6%E4%BD%9CFramework%E9%9D%99%E6%80%81%E5%BA%93/"/>
    <id>http://yoursite.com/2017/08/07/iOS中制作Framework静态库/</id>
    <published>2017-08-07T10:47:18.000Z</published>
    <updated>2017-08-07T11:06:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>iOS开发中我们经常需要用到各种库，比如开源库AFNetworking,静态库BaiduMapAPI_Base.framework（百度地图SDK）,还有系统动态库UIKit.framework等等，今天我们来学习一下相关知识并自己制作一个framework静态库。<br><a id="more"></a></p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><p>什么是库？</p>
<p>库是程序代码的集合，是共享程序代码的一种方式。<br>根据源代码的公开情况，库可以分为开源库和闭源库两种类型。</p>
<p>开源库：公开源代码，能看到具体实现，比如 SDWebImage 、 AFNetworking。</p>
<p>闭源库：不公开源代码，是经过编译后的二进制文件，看不到具体实现，主要分为静态库和动态库。</p>
<h3 id="静态库和动态库"><a href="#静态库和动态库" class="headerlink" title="静态库和动态库"></a>静态库和动态库</h3><p>1、静态库和静态库的存在形式</p>
<p>静态库：.a和.framework</p>
<p>动态库：.dylib(现在为.tbd)和.framework</p>
<p>2、静态库和动态库使用时的区别</p>
<p>静态库：链接时，静态库会被完整地复制到可执行文件中， 被多次使用就有多份冗余拷贝；</p>
<p>动态库：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。</p>
<p><img src="http://osv8n47s0.bkt.clouddn.com/blog/1424051789719516.png" alt="静态库使用"><br><img src="http://osv8n47s0.bkt.clouddn.com/blog/1424051789127826.png" alt="动态库使用"></p>
<p>3、.a与.framework的区别</p>
<p>.a是纯二进制文件，.a文件不能单独使用，至少要有.h文件配合；</p>
<p>.framework除了二进制文件外，还包含一些资源文件（头文件，plist等），由于自身包含了头文件，所以.framework可以单独使用。</p>
<h2 id="制作framework静态库"><a href="#制作framework静态库" class="headerlink" title="制作framework静态库"></a>制作framework静态库</h2><h3 id="创建静态库工程"><a href="#创建静态库工程" class="headerlink" title="创建静态库工程"></a>创建静态库工程</h3><p>新建一个项目，选择Cocoa Touch Framework<br><img src="http://osv8n47s0.bkt.clouddn.com/select_template.png" alt="选择工程模板"><br>将静态库命名为SONGTestLib（名字随便起），并填写其他必要信息<br><img src="http://osv8n47s0.bkt.clouddn.com/Snip20170803_1.png" alt=""><br>新建完成之后，项目中会自动生成一个头文件SONGTestLib.h(工程名.h),创建其他相关代码文件并编写代码<br><img src="http://osv8n47s0.bkt.clouddn.com/add_code.png" alt=""><br>选择工程文件&gt;target&gt;Build Settings&gt;Linking&gt;Mach-O Type，设置为Static Library，因为系统默认创建的是动态库，需要设置此项才能生成静态库。<br><img src="http://osv8n47s0.bkt.clouddn.com/select_type.png" alt="选择库类型"><br>选择工程文件&gt;target&gt;Build Phases&gt;Headers,将需要公开的头文件从Project中拖入Public。<br><img src="http://osv8n47s0.bkt.clouddn.com/select_headers.png" alt="公开头文件"><br>将需要公开的.h文件都用<code>#import&lt;SONGTestLib/PublicHeader.h&gt;</code>形式引入,记住一定要将所有的需要公开的.h文件都写在给定的.h文件中,不然编译后生成的.framework在引用的时候会有警告。<br><img src="http://osv8n47s0.bkt.clouddn.com/Snip20170803_3.png" alt="引入公开的头文件"></p>
<h3 id="添加资源文件（可选）"><a href="#添加资源文件（可选）" class="headerlink" title="添加资源文件（可选）"></a>添加资源文件（可选）</h3><p>有时候我们的静态库中也需要图片素材等外部资源，此时我们可以将这些资源文件一起打包到framework中。</p>
<p>创建.bundle：外部资源不能直接打包到framework静态库中，必须将资源放到.bundle中。创建.bundle很简单，直接新建一个文件夹，将文件夹添加后缀.bundle即可。</p>
<blockquote>
<p>bundle是静态的，也就是说，我们包含到包中的资源文件作为一个资源包是不参加项目编译的。也就意味着，bundle包中不能包含可执行的文件。它仅仅是作为资源，被解析成为特定的2进制数据。</p>
</blockquote>
<p>将.bundle添加到静态库工程中：直接将.bundle拖入到工程中即可</p>
<h3 id="生成通用的静态库"><a href="#生成通用的静态库" class="headerlink" title="生成通用的静态库"></a>生成通用的静态库</h3><p>此时对工程进行编译已经可以生成静态库，但按照工程默认的设置，静态库并不是支持所有的架构。因为我们的静态库是给别人用的，所以一般会支持所有的架构，模拟器和真机的各种机型都要支持，所以还需要一定的工作来生成通用的静态库。</p>
<h5 id="Debug和Release版本"><a href="#Debug和Release版本" class="headerlink" title="Debug和Release版本"></a>Debug和Release版本</h5><ul>
<li>一般来说, 我们应该发布的是release版本。</li>
<li>debug:调试版本, 系统本身也会有一些调试代码. 此版本体积会稍大, 运行会稍慢。</li>
<li>release: 发布版本, 系统会去除调试代码, 体积变小, 运行速度变快. 对用户来说没有明显的感觉。</li>
</ul>
<h5 id="导出Products静态库的配置"><a href="#导出Products静态库的配置" class="headerlink" title="导出Products静态库的配置"></a>导出Products静态库的配置</h5><p>在静态库工程中，如果配置中的Build Active Architecture Only设置为YES的话，导出的静态库只包含当前的架构。在默认配置中Targets&gt;Build Settings&gt;Build Active Architecture Only,Debug为YES,release为NO，我们要发布的也是release版本，所以要确保这一步没有修改。</p>
<p>修改Scheme:<br><img src="http://osv8n47s0.bkt.clouddn.com/edit_scheme.png" alt="编辑Scheme"><br>将Build Configuration为Release<br><img src="http://osv8n47s0.bkt.clouddn.com/select_release.png" alt="修改为release"></p>
<h4 id="分别导出模拟器和真机版本的静态库"><a href="#分别导出模拟器和真机版本的静态库" class="headerlink" title="分别导出模拟器和真机版本的静态库"></a>分别导出模拟器和真机版本的静态库</h4><p>先选择Generic iOS Device，按下Command+B：Build一下</p>
<p>然后随意选择一个模拟器再次Build一下</p>
<p>找到Build后的framework<br><img src="http://osv8n47s0.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-03%20%E4%B8%8B%E5%8D%882.44.56.png" alt="找到静态库"><br>我们看到总共有两个文件夹，Release-iphoneos文件夹中是真机编译生成的文件，Release-iphonesimulator文件夹中是模拟器编译生成的文件。<br><img src="http://osv8n47s0.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-03%20%E4%B8%8B%E5%8D%882.46.16.png" alt="两种静态库"></p>
<h4 id="合并静态库的模拟器与真机架构"><a href="#合并静态库的模拟器与真机架构" class="headerlink" title="合并静态库的模拟器与真机架构"></a>合并静态库的模拟器与真机架构</h4><blockquote>
<p>合并之后的动态/静态库要与原来的名称一致，不然用的时候编译会报错</p>
<p>合并的主要是是framework下的同名文件</p>
</blockquote>
<p>我们将合并后的文件放到Products文件夹下,命令行为<pre><code>lipo -create /Users/songbo/Library/Developer/Xcode/DerivedData/SONGTestLib-dalamcasyjusbjcoiswoasefbbuq/Build/Products/Release-iphonesimulator/SONGTestLib.framework/SONGTestLib /Users/songbo/Library/Developer/Xcode/DerivedData/SONGTestLib-dalamcasyjusbjcoiswoasefbbuq/Build/Products/Release-iphoneos/SONGTestLib.framework/SONGTestLib -output /Users/songbo/Library/Developer/Xcode/DerivedData/SONGTestLib-dalamcasyjusbjcoiswoasefbbuq/Build/Products/SONGTestLib</code></pre></p>
<p><img src="http://osv8n47s0.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-03%20%E4%B8%8B%E5%8D%882.50.48.png" alt="合并架构的命令截图"><br>这里解释一下这看似很复杂的命令：lipo -create +被合成的两个原来文件的路径 + -output + 合成后文件的输出路径 ，所以上面命令执行之后会在Products文件夹下生成合成之后的文件<br><img src="http://osv8n47s0.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-03%20%E4%B8%8B%E5%8D%882.50.17.png" alt="合成后的文件"><br>将合成之后的文件SONGTestLib替换掉之前Release-iphoneos中framework中的SONGTestLib,此时Release-iphoneos中framework即是我们合成之后可以使用的framework。</p>
<h4 id="验证合并后的静态库架构"><a href="#验证合并后的静态库架构" class="headerlink" title="验证合并后的静态库架构"></a>验证合并后的静态库架构</h4><p>验证静态库架构的代码为lipo -info + 静态库文件路径</p>
<p>例如验证我们上面制作的静态库架构</p>
<p><pre><code>lipo -info /Users/songbo/Library/Developer/Xcode/DerivedData/SONGTestLib-dalamcasyjusbjcoiswoasefbbuq/Build/Products/Release-iphoneos/SONGTestLib.framework/SONGTestLib</code></pre><br><img src="http://osv8n47s0.bkt.clouddn.com/Snip20170807_1.png" alt="验证静态库架构"><br>验证显示我们制作的静态库架构包括i386 armv7 x86_64 arm64，符合我们的要求。</p>
<p>至此，静态库制作完成。</p>
<h2 id="使用静态库"><a href="#使用静态库" class="headerlink" title="使用静态库"></a>使用静态库</h2><h3 id="添加静态库"><a href="#添加静态库" class="headerlink" title="添加静态库"></a>添加静态库</h3><p>将上文制作好的静态库直接拖入到需要使用静态库的项目中，注意将Copy items if needed打勾，<br><img src="http://osv8n47s0.bkt.clouddn.com/Snip20170807_2.png" alt="勾选Copy items if needed"></p>
<h3 id="使用资源文件-可选-与制作静态库时对应"><a href="#使用资源文件-可选-与制作静态库时对应" class="headerlink" title="使用资源文件(可选,与制作静态库时对应)"></a>使用资源文件(可选,与制作静态库时对应)</h3><p>如果制作静态库时，在静态库中添加了.bundle形式的资源文件，此时如果资源文件是必须用的，还必须要将资源文件添加到当前的工程项目中：</p>
<p>方法：选中工程名，在右键菜单中选择Add Files to “工程名”…，从SONGTestLib.framework中选择mapapi.bundle文件，并勾选“Copy items if needed”复选框，单击“Add”按钮，将资源文件添加到工程中。<br><img src="http://osv8n47s0.bkt.clouddn.com/Snip20170807_3.png" alt="添加资源文件"></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>如果静态库内有 category 分类，那么需要在添加 -ObjC 编译标识，否则可能会报：unrecognized selector sent to instance。</p>
<p>方法：选择工程文件&gt;target&gt;Build Settings&gt;Linking&gt;Other Linker Flags，设置为-ObjC<br><img src="http://osv8n47s0.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-08-03%20%E4%B8%8B%E5%8D%883.00.33.png" alt="设置-ObjC"></p>
<blockquote>
<p>其他编译参数说明</p>
<p>1、<code>－ObjC</code>：加了这个参数后，链接器就会把静态库中所有的Objective-C类和分类都加载到最后的可执行文件中。</p>
<p>2、<code>－all_load</code>：会让链接器把所有找到的目标文件都加载到可执行文件中，但是千万不要随便使用这个参数！假如你使用了不止一个静态库文件，然后又使用了这个参数，那么你很有可能会遇到ld: duplicate symbol错误，因为不同的库文件里面可能会有相同的目标文件，所以建议在遇到<code>-ObjC</code>失效的情况下使用<code>-force_load</code>参数。</p>
<p>3、<code>-force_load</code>：所做的事情跟<code>-all_load</code>其实是一样的，但是<code>-force_load</code>需要指定要进行全部加载的库文件的路径，这样的话，你就只是完全加载了一个库文件，不影响其余库文件的按需加载。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://www.infocool.net/kb/IOS/201610/196771.html" target="_blank" rel="external">ios开发：Xcode8制作framework及使用</a></li>
<li><a href="http://billchan.me/2016/07/31/how-to-use-static-library-in-ios/" target="_blank" rel="external">iOS 中静态链接库的使用</a></li>
<li><a href="http://blog.csdn.net/tianshats/article/details/52045974" target="_blank" rel="external">IOS开发中制作属于自己的静态库.a、资源库.bundle、.framework</a></li>
<li><a href="http://www.jianshu.com/p/f9befc134dbc" target="_blank" rel="external">iOS中的静态库 .a 和 .framework &amp;&amp; 资源库.bundle</a></li>
<li><a href="https://my.oschina.net/kaqijiang/blog/649632" target="_blank" rel="external">iOS静态库 【.a 和framework】</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;iOS开发中我们经常需要用到各种库，比如开源库AFNetworking,静态库BaiduMapAPI_Base.framework（百度地图SDK）,还有系统动态库UIKit.framework等等，今天我们来学习一下相关知识并自己制作一个framework静态库。&lt;br&gt;
    
    </summary>
    
    
      <category term="iOS,技术" scheme="http://yoursite.com/tags/iOS-%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>未来已来 - 打开新世界</title>
    <link href="http://yoursite.com/2017/07/11/%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5-%E6%89%93%E5%BC%80%E6%96%B0%E4%B8%96%E7%95%8C/"/>
    <id>http://yoursite.com/2017/07/11/未来已来-打开新世界/</id>
    <published>2017-07-11T02:18:47.000Z</published>
    <updated>2017-07-11T02:28:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hi,大家好，我是此刻柳暗花明，本名宋波，目前在做iOS开发。我希望自己会是一个实干家，因为我有很多梦想，我想看到它们开花结果。欢迎来到我的地盘，嘿嘿！😜<br><a id="more"></a></p>
<blockquote>
<p>赠人玫瑰，手有余香。</p>
</blockquote>
<p>最近抽时间搭建了真正属于自己的博客，今后我会在此分享学习心得，记录生活感受。如果能够在写作过程中帮助到一些人，或者为他们带去一些启发，我一定会非常开心。</p>
<p>每个人都会憧憬更加美好的未来，而未来从哪里来？从此刻来。好好的把握现在，认真的活在当下，一切希望都会水到渠成，我们都会此刻柳暗花明。</p>
<p>未来已来——未来由此刻创造，未来诞生于此刻。新世界已打开，我是此刻柳暗花明，祝你好运！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hi,大家好，我是此刻柳暗花明，本名宋波，目前在做iOS开发。我希望自己会是一个实干家，因为我有很多梦想，我想看到它们开花结果。欢迎来到我的地盘，嘿嘿！😜&lt;br&gt;
    
    </summary>
    
    
      <category term="感悟" scheme="http://yoursite.com/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
</feed>

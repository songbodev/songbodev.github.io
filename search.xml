<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS知识专题之GCD学习笔记四]]></title>
    <url>%2F2018%2F03%2F19%2FiOS%E7%9F%A5%E8%AF%86%E4%B8%93%E9%A2%98%E4%B9%8BGCD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[前言:本文是GCD学习笔记的最后一篇,主要是GCD的一些高阶(特殊)用法，这些用法在日常的业务编程中通常不会用到，但是在对整个程序的控制（比如调试或测试）上会大有用武之地。 一、在正确的场景下，主动阻塞线程问题背景Xcode自带单元测试（Unit Tests）功能，当我们在代码里构建复杂关系时编写和运行测试非常有用。 Xcode 里的测试在 XCTestCase 的子类上执行，并运行任何方法签名以 test 开头的方法。测试在主线程运行，所以可以假设所有测试都是串行发生的。 当一个给定的测试方法运行完成，XCTest 方法将考虑此测试已结束，并进入下一个测试。这意味着任何来自前一个测试的异步代码会在下一个测试运行时继续运行。 网络代码通常是异步的，因此在执行网络获取时我们并没有阻塞主线程。也就是说，整个测试会在测试方法完成之后结束，这会让对网络代码的测试变得很困难。也就是，除非在测试方法内部阻塞主线程直到网络代码完成。 我们可以采用一种很幼稚的方法来达到目的:在测试函数的最后通过一个while循环来阻塞函数的执行。但实际上，这种实现就是一个基本的自旋锁。它很不实用，因为在 While 循环里浪费了珍贵的 CPU 周期；而且它也几乎没有扩展性。 信号量GCD解决这个问题，需要用到一个概念——信号量。信号量是一种老式的线程概念，它之所以比较复杂是因为它建立在操作系统的复杂性之上。 信号量使得我们可以控制多个消费者对有限数量资源的访问。举例来说，如果创建了一个有着两个资源的信号量，那同时最多只能有两个线程可以访问临界区。其他想使用资源的线程必须在一个FIFO队列里等待。 使用信号量阻塞线程使用信号量阻塞当前线程的步骤如下: 1.创建一个信号量。 dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); 参数指定信号量的起始值。这个数字是当前可以访问的信号量。这里初始化为0，也就是说，如果有人想使用信号量必然会被阻塞，直到有人增加(发射)信号量。 2.在异步执行函数里调用相应的方法,告诉信号量不再需要资源了,这就会增加信号量的计数并告知其他想使用此资源的线程。 dispatch_semaphore_signal(semaphore); 3.调用dispatch_semaphore_wait阻塞当前线程并设置超时时间。 这个调用会阻塞当前线程直到信号量被发射或者超时，这个函数的一个非零返回值表示到达超时了。 二、使用Dispatch SourceGCD 的一个特别有趣的特性是 Dispatch Source，它基本上就是一个低级函数的 grab-bag ，能帮助你去响应或监测 Unix 信号、文件描述符、Mach 端口、VFS 节点，以及其它晦涩的东西。能够在合适的地方使用这些特性，能帮我们做很多有趣又有用的事情。比如此处要介绍的一种用法，在调试或者编写调试器时就很有用。 创建dispatch_source_t创建一个dispatch_source_t的创建的函数原型为 dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, unsigned long mask, dispatch_queue_t _Nullable queue); 第一个参数是 dispatch_source_type_t 。这是最重要的参数，因为它决定了 handle 和 mask 参数将会是什么。可以查看 Xcode 文档 得到哪些选项可用于每个 dispatch_source_type_t 参数。最后一个参数代表在哪个队列上处理接收到的事件。 例如,DISPATCH_SOURCE_TYPE_SIGNAL代表的是一个监控当前进程信号的 Dispatch Source。此时handle 是信号编号，mask 未使用（传 0 即可）。 这些 Unix 信号组成的列表可在头文件 signal.h中找到。在其顶部有一堆 #define 语句。比如我们可以监控此信号列表中的 SIGSTOP 信号。这个信号将会在进程接收到一个无法回避的暂停指令时被发出。我们在用 LLDB 调试器调试应用时使用的也是这个信号。 如下是创建dispatch_source_t的示例代码: dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGSTOP, 0, dispatch_get_main_queue()); 利用dispatch_source_set_event_handler设置条件达成时需要执行的任务代码这里只需要调用函数dispatch_source_set_event_handler，设置对应的dispatch source和条件达成时需要执行的任务代码即可。 dispatch_source_set_event_handler(source, ^{ //收到所监控的信号时,需要执行的代码 }); 激活源对象默认的，所有源初始都为暂停状态。如果要开始监控事件，必须告诉源对象恢复活跃状态。 dispatch_resume(source);//激活源对象 应用场景因为上面提到的SIGSTOP信号会在我们使用LLDB 调试器调试应用时发出,所以我们可以应用对这个信号的监控来自定义调试器。比如: 我们可以用它去调试一个对象并在任何想恢复应用的时候显示数据。 同样地，我们能给应用加上自定义的安全逻辑以便在恶意攻击者将一个调试器连接到应用上时保护自己（或用户的数据）。 自定义一个堆栈追踪工具去找到我们想在调试器里操纵的对象。 当意外地停止调试器，我们几乎从来都不会在所需的栈帧上。现在利用信号监控我们可以在任何时候停止调试器并在所需的地方执行代码。 如果我们想在应用的某一点执行的代码非常难以从调试器访问的话，这会非常有用。 最后到此,GCD学习笔记的整理也告一段落了。相对于NSOperationQueue和NSThread等技术，GCD更加底层,同时也更加高效,在优化应用、多线程开发和并发编程时，GCD都会是一个很好的选择。 参考链接GCD 深入理解：第二部分]]></content>
      <tags>
        <tag>iOS 技术 GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS知识专题之GCD学习笔记三]]></title>
    <url>%2F2018%2F03%2F19%2FiOS%E7%9F%A5%E8%AF%86%E4%B8%93%E9%A2%98%E4%B9%8BGCD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89%2F</url>
    <content type="text"><![CDATA[前言:这是GCD学习笔记的第三篇,主要总结了Dispatch Groups和dispatch_apply两个知识点。Dispatch Groups主要用于对批量执行的异步任务进行监控,而dispatch_apply可用于并发执行迭代操作。 一、使用Dispatch Groups（调度组）在开发中，有时候我们会遇到这样的需求：我们需要异步的执行多个任务,并在所有任务执行完成时再进行另外的某个操作，此时实际上我们是需要监控并发的异步事件执行进度。 解决这种对多个异步任务的完成进行监控的问题，恰好就是设计 dispatch_group 的目的。 Dispatch Group 会在整个组的任务都完成时通知你。这些任务可以是同步的，也可以是异步的，即便在不同的队列也行。而且在整个组的任务都完成时，Dispatch Group 可以用同步的或者异步的方式通知你。因为要监控的任务在不同队列，我们需要用一个 dispatch_group_t 的实例来记下这些不同的任务。 当组中所有的事件都完成时，GCD 的 API 提供了两种通知方式。 dispatch_group_wait方式:它会阻塞当前线程，直到组里面所有的任务都完成或者等到某个超时发生。 dispatch_group_notify方式:以异步的方式工作。当 Dispatch Group 中没有任何任务时，它就会执行其代码。这种方式通常是第一选择,因为既达到了我们的目的，又没有阻塞任何线程。 dispatch_group_wait方式通常的实现步骤如下: 利用dispatch_async异步将多个任务执行的block放在并发队列执行； 创建dispatch_group_t，它的作用就像一个用于未完成任务的计数器。dispatch_group_t downloadGroup = dispatch_group_create(); 每个任务执行开始前，调用dispatch_group_enter(downloadGroup);通知 Dispatch Group 任务已经开始。 在每个任务完成之后,调用dispatch_group_leave(downloadGroup);手动通知 Group 它的工作已经完成。需要注意的是，必须保证 dispatch_group_enter 和 dispatch_group_leave 成对出现,即必须要确保进入 Group 的次数和离开 Group 的次数相等。 调用dispatch_group_wait设定等待时间,其中第二个参数为超时时间。例如dispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER);设置了永远等待。dispatch_group_wait 会一直等待，直到任务全部完成或者超时。如果在所有任务完成前超时了，该函数会返回一个非零值。你可以对此返回值做条件判断以确定是否超出等待周期。 任务都完成之后将会执行dispatch_group_wait之后的代码，此时可以进行后续操作，比如dispatch_async到主线程刷新UI等。 dispatch_group_notify方式通常的实现步骤如下: 创建dispatch_group_t。 利用dispatch_apply,并发迭代不同的任务。 在每个任务执行开始前，调用dispatch_group_enter通知 Dispatch Group 任务已经开始。 在每个任务完成之后,调用dispatch_group_leave手动通知 Group 它的工作已经完成。再次强调，必须要确保进入 Group 的次数和离开 Group 的次数相等。 使用dispatch_group_notify监听group中任务的完成，并注册任务完成之后要执行的任务和相应的执行线程。 dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^{ //监听的所有任务执行完成之后需要执行的代码 }); 在Dispatch Group上如何使用 队列类型 快速指导: 自定义串行队列：它很适合当一组任务完成时发出通知。 主队列（串行）：它也很适合这样的情况。但如果你要同步地等待所有工作地完成，那你就不应该使用它，因为你不能阻塞主线程。然而，异步模型是一个很有吸引力的能用于在几个较长任务（例如网络调用）完成后更新 UI 的方式。 并发队列：它也很适合 Dispatch Group 和完成时通知。 二、使用dispatch_apply并发执行迭代dispatch_apply 表现得就像一个 for 循环，但它能并发地执行不同的迭代。这个函数是同步的，所以和普通的 for 循环一样，它只会在所有工作都完成后才会返回。 注意for循环是串行的,顺序是固定的；而dispatch_apply迭代是并发的,同时它不能保证执行顺序。 过多的并发迭代并不一定效率更高，要在适当的场景使用并发迭代。当在 Block 内计算任何给定数量的工作的最佳迭代数量时，必须要小心，因为过多的迭代和每个迭代只有少量的工作会导致大量开销以致它能抵消任何因并发带来的收益。而被称为跨越式（striding）的技术可以在此帮到你，即通过在每个迭代里多做几个不同的工作。 创建并行运行线程而付出的开销，很可能比直接使用 for 循环要多。若你要以合适的步长迭代非常大的集合，那才应该考虑使用 dispatch_apply 在dispatch_apply上如何使用 队列类型 快速指导: 自定义串行队列：串行队列会完全抵消 dispatch_apply 的功能；你还不如直接使用普通的 for 循环。 主队列（串行）：与上面一样，在串行队列上不适合使用 dispatch_apply 。还是用普通的 for 循环吧。 并发队列：对于并发循环来说是很好选择，特别是当你需要追踪任务的进度时。 总结来说,使用dispatch_apply的最佳实践是使用在并发队列上。 参考链接GCD 深入理解：第二部分]]></content>
      <tags>
        <tag>iOS 技术 GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS知识专题之GCD学习笔记二]]></title>
    <url>%2F2018%2F03%2F19%2FiOS%E7%9F%A5%E8%AF%86%E4%B8%93%E9%A2%98%E4%B9%8BGCD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[说明:和上一篇GCD学习笔记一样,本篇文章主要内容还是来自于这篇博客。笔者只是对内容进行了少量的修改并加入了自己的一些总结，供后续查阅。 GCD常用函数使用详解一、用 dispatch_async 处理后台任务dispatch_async 添加一个 Block 到队列就立即返回了。任务会在之后由 GCD 决定执行。当你需要在后台执行一个基于网络或 CPU 紧张的任务时就使用 dispatch_async ，这样就不会阻塞当前线程。例如: //这里是主线程 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ //多线程执行,网络或耗时操作 //... dispatch_async(dispatch_get_main_queue(), ^{ //主线程执行,更新UI等 //... }); }); 在 dispatch_async 上如何使用 队列类型 快速指导: 自定义串行队列：当你想串行执行后台任务并追踪它时就是一个好选择。这消除了资源争用，因为你知道一次只有一个任务在执行。注意若你需要来自某个方法的数据，你必须内联另一个 Block 来找回它或考虑使用 dispatch_sync。 主队列（串行）：这是在一个并发队列上完成任务后更新 UI 的共同选择。要这样做，你将在一个 Block 内部编写另一个 Block 。以及，如果你在主队列调用 dispatch_async 到主队列，你能确保这个新任务将在当前方法完成后的某个时间执行。 并发队列：这是在后台执行非 UI 工作的共同选择。 二、使用 dispatch_after 延后工作dispatch_after 工作起来就像一个延迟版的 dispatch_async (也是异步的执行)。你依然不能控制实际的执行时间，且一旦 dispatch_after 返回也就不能再取消它。示例代码如下: dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC)); dispatch_after(popTime, dispatch_get_main_queue(), ^(void){ //在delayInSeconds秒之后将执行的代码 }); 在 dispatch_after 上如何使用 队列类型 快速指导: 自定义串行队列：在一个自定义串行队列上使用 dispatch_after 要小心。你最好坚持使用主队列。 主队列（串行）：是使用 dispatch_after 的好选择；Xcode 提供了一个不错的自动完成模版。 并发队列：在并发队列上使用 dispatch_after 也要小心；你会这样做就比较罕见。还是在主队列做这些操作吧。 总结起来，其实就是，dispatch_after只用在主队列dispatch_get_main_queue()上。 三、使用dispatch_once()创建单例,让单例线程安全 dispatch_once() 以线程安全的方式执行且仅执行其代码块一次。试图访问临界区（即传递给 dispatch_once 的代码）的不同的线程会在临界区已有一个线程的情况下被阻塞，直到临界区完成为止。 综上，单例的初始化方法可以用类似下面的代码实现: + (instancetype)sharedManager { static CustomManager *sharedManager = nil; static dispatch_once_t onceToken; dispatch_once(&onceToken, ^{ sharedManager = [[CustomManager alloc] init]; //其他属性的设置 }); return sharedManager; } 四、利用dispatch_barrier解决读者与写者问题Foundation的容器类一般都有对应的可变容器类，它们（比如 NSMutableArray ）一般都是线程不安全的,因为它们经常需要解决读者写者问题。 GCD 通过用 dispatch barriers 创建一个读者写者锁 提供了一个优雅的解决方案。 Dispatch barriers 是一组函数，在并发队列上工作时扮演一个串行式的瓶颈。使用 GCD 的障碍（barrier）API 确保提交的 Block 在那个特定时间上是指定队列上唯一被执行的条目。这就意味着所有的先于调度障碍提交到队列的条目必能在这个 Block 执行前完成。 当这个 Block 的时机到达，调度障碍执行这个 Block 并确保在那个时间里队列不会执行任何其它 Block 。一旦完成，队列就返回到它默认的实现状态。GCD 提供了同步和异步两种障碍函数。 下图显示了障碍函数对多个异步并发队列的影响： 注意到正常部分的操作就如同一个正常的并发队列。但当障碍执行时，它本质上就如同一个串行队列。也就是，障碍是唯一在执行的事物。在障碍完成后，队列回到一个正常并发队列的样子。 在 dispatch_barrier 上如何使用 队列类型 快速指导: 自定义串行队列：一个很坏的选择；障碍不会有任何帮助，因为不管怎样，一个串行队列一次都只执行一个操作。 全局并发队列：要小心；这可能不是最好的主意，因为其它系统可能在使用队列而且你不能垄断它们只为你自己的目的。因为障碍执行时，可能导致系统的某些代码执行被阻塞。 自定义并发队列：这对于原子或临界区代码来说是极佳的选择。任何你在设置或实例化的需要线程安全的事物都是使用障碍的最佳候选。 总结起来就是,使用dispatch_barrier都用在自定义并发队列上。 写操作的示例代码如下: dispatch_barrier_async(self.concurrentPhotoQueue, ^{ //这里是障碍block，临界区代码，这个 Block 永远不会同时和其它 Block 一起在 concurrentPhotoQueue 中执行，这里的代码执行时，这些代码将是队列中唯一执行的条目。 dispatch_async(dispatch_get_main_queue(), ^{ //如果需要更新UI等操作,需要使用主队列来调用 }); }); 注:self.concurrentPhotoQueue是自定义并发队列。 另外需要注意的是，到这里并没有结束,必须将写操作和读操作同时用在同一个障碍队列中，才可以实现读者和写者的线程安全。 读操作通常需要用到dispatch_sync，因为需要等待读取操作完成之后才能返回; 在 dispatch_sync 上如何使用 队列类型 快速指导: 自定义串行队列：在这个状况下要非常小心！如果你正运行在一个队列并调用 dispatch_sync 放在同一个队列，那你就百分百地创建了一个死锁。 主队列（串行）：同上面的理由一样，必须非常小心！这个状况同样有潜在的导致死锁的情况。 并发队列：这才是做同步工作的好选择，不论是通过调度障碍，或者需要等待一个任务完成才能执行进一步处理的情况。 总结来说,dispatch_sync只应该用在并发队列上。 读操作的示例代码如下: - (NSArray *)objects { __block NSArray *array; dispatch_sync(self.concurrentPhotoQueue, ^{ array = [NSArray arrayWithArray:_objectsArray]; }); return array; } 五、总结:dispatch_async 和 dispatch_sync 的对比理解dispatch_sync 添加任务到一个队列并等待直到任务完成。dispatch_async做类似的事情，但不同之处是它不会等待任务的完成，而是立即继续“调用线程”的其它任务。 多线程开发Tips多线程开发中有很多需要注意的点或者比较好的实践，本文将一些常见的Tips列下来，供参考。 必须总是在主线程访问 UIKit 的类。 如果计划优化自己项目，可以利用 Instruments 中的 Time Profile 模版来分析项目中的CPU占用情况。 使用Instruments进行分析时,最好采用真机来测试，会比模拟器更加准确。 网络请求的相关需求常常会用到多线程，我们可以通过一些手段模拟网络比较差的环境来进行测试：真机可以在设置——&gt;开发者——&gt;Network Link Conditioner——&gt;开启并选择一个profile来实现；模拟器可以使用来自 GitHub 的 Network Link Conditioner来改变网络速度。 我们用于创建项目的时间是有限的，除非实在太糟糕否则不要浪费时间去提前优化代码。如果想要进行一定的优化，那就去优化那些明显值得付出时间的部分。我们可以通过在 Instruments 里分析项目运行情况，找出最长运行时间的方法。 通常情况下，优化代码会让代码更加复杂，不利于自己和其他开发者阅读。请确保添加的复杂性能换来足够多的好处。 参考链接GCD 深入理解：第一部分]]></content>
      <tags>
        <tag>iOS 技术 GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS知识专题之AR开发框架Vuforia学习笔记]]></title>
    <url>%2F2018%2F03%2F16%2FiOS%E7%9F%A5%E8%AF%86%E4%B8%93%E9%A2%98%E4%B9%8BAR%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6Vuforia%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言Vuforia是一个知名的AR开发框架，同时支持iOS和Android开发平台。 众所周知，苹果在iOS11推出了自己的AR开发框架ARKit，但是仍有较大的局限性，比如在硬件上只支持iPhone6s及以后的设备，包括iPhoneSE，主要是需要A9以上的芯片支持；而Android端目前还没有官方统一的AR支持框架。所以在需要进行移动端的AR开发时，Vuforia框架是一个不错的选择。 本文其实是自己研究Vuforia框架的学习笔记，仅供参考，如有错误请批评指正。 几个比较重要的类Vuforia官方提供了三种类型的API:Unity,C++和Java。三种类型API的内容都是一一对应的，所以只需要选择适合自己的一种API进行学习使用即可。 Vuforia::StateState中保存了当前AR环境中的摄像机帧和所有的trackables可跟踪对象。和Frame类似，State是个轻量级的对象，它的数据实际上保存在多个（其他类的）实例中。从State中查询的Trackables不能和从tracker中查询的Trackables指针比较，即使它们可能引用的是同一个对象。从state中查询的Trackables代表AR状态中临时的，不可变的view,因此不能修改。要想修改它们，必须从Tracker中查询它们。 在State中可能会包含有多个TrackableResult，因此可以从State中可以获取当前的某个TrackableResult对象。 Vuforia::TrackableResult顾名思义，TrackableResult其实就是一个“跟踪的结果”，代表的是一个Trackable 在某一帧中的状态。 我们可以通过其实例方法获取到当前结果的各种参数，包括Pose(当前的姿势或位置矩阵)和Trackable （可跟踪的对象）。 Vuforia::TrackableTrackable是所有可被跟踪对象的基类。子类主要包括，锚点类，可跟踪的设备，模型，以及单词word等。 使用它的实例方法我们可以获取到当前被跟踪对象的名称，类型，是否extended tracking可扩展跟踪等信息。 参考链接 Vuforia官方网站 Vuforia框架C++ API索引]]></content>
      <tags>
        <tag>Vuforia AR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS知识专题之GCD学习笔记一]]></title>
    <url>%2F2018%2F03%2F12%2FiOS%E7%9F%A5%E8%AF%86%E4%B8%93%E9%A2%98%E4%B9%8BGCD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[前言GCD是iOS和Mac OS X开发中处理并发的一个重要的底层技术，并且代码是开源的(代码地址)。它具有以下优点: GCD 能通过推迟昂贵计算任务并在后台运行它们来改善你的应用的响应性能; GCD 提供一个易于使用的并发模型而不仅仅只是锁和线程，以帮助我们避开并发陷阱; GCD 具有在常见模式（例如单例）上用更高性能的原语优化你的代码的潜在能力。 GCD与线程和并发紧密相关，而相关的概念又比较多，容易混淆。本文是笔者学习GCD的笔记，只是为了便于加深记忆和以后查询，本文中的绝大部分内容都来自于这篇博客,又加入了自己的一些总结，感谢大神的贡献。 相关概念Serial vs. Concurrent 串行 vs. 并发这些术语描述当任务相对于其它任务被执行，任务串行执行就是每次只有一个任务被执行，任务并发执行就是在同一时间可以有多个任务被执行。 Synchronous vs. Asynchronous 同步 vs. 异步在 GCD 中，这些术语描述当一个函数相对于另一个任务完成，此任务是该函数要求 GCD 执行的。 一个同步函数只在完成了它预定的任务后才返回; 一个异步函数，刚好相反，会立即返回，预定的任务会完成但不会等它完成。因此，一个异步函数不会阻塞当前线程去执行下一个函数。 Critical Section 临界区就是一段代码不能被并发执行，也就是，两个线程不能同时执行这段代码。这很常见，因为代码去操作一个共享资源，例如一个变量若能被并发进程访问，那么它很可能会变质（它的值不再可信）。 临界区通俗的说，其实就是这个“区域”不能在不同线程同时去访问。 Race Condition 竞态条件这种状况是指基于特定序列或时机的事件的软件系统以不受控制的方式运行的行为，例如程序的并发任务执行的确切顺序。竞态条件可导致无法预测的行为，而不能通过代码检查立即发现。 在并发任务中，写在前面的任务并不一定先执行结束，如果想当然的认为先写的代码就会先结束，就可能会导致竞态条件。 Deadlock 死锁两个（有时更多）东西——在大多数情况下，是线程——所谓的死锁是指它们都卡住了，并等待对方完成或执行其它操作。第一个不能完成是因为它在等待第二个的完成。但第二个也不能完成，因为它在等待第一个的完成。 两个线程都卡住了,因为它们都在等待对方的完成。 Thread Safe 线程安全线程安全的代码能在多线程或并发任务中被安全的调用，而不会导致任何问题（数据损坏，崩溃，等）。线程不安全的代码在某个时刻只能在一个上下文中运行。 一个线程安全代码的例子是 NSDictionary 。你可以在同一时间在多个线程中使用它而不会有问题。另一方面，NSMutableDictionary 就不是线程安全的，应该保证一次只能有一个线程访问它。 Context Switch 上下文切换一个上下文切换指当你在单个进程里切换执行不同的线程时存储与恢复执行状态的过程。这个过程在编写多任务应用时很普遍，但会带来一些额外的开销。 Concurrency vs Parallelism 并发与并行我们知道,并发代码的不同部分可以“同步”执行(即可以同时的执行)。然而，该怎样发生或是否发生都取决于系统。多核设备通过并行来同时执行多个线程；然而，为了使单核设备也能实现这一点，它们必须先运行一个线程，执行一个上下文切换，然后运行另一个线程或进程。这通常发生地足够快以致给我们并发执行地错觉，如下图所示： 上图中,上面的是真正的并行,而下面是并发,但是并未真正的并行，只是我们有一种“并行的错觉”。 虽然你可以编写代码在 GCD 下并发执行，但 GCD 会决定有多少并行的需求。并行要求并发，但并发并不能保证并行。 更深入的观点是并发实际上是关于构造。当你在脑海中用 GCD 编写代码，你组织你的代码来暴露能同时运行的多个工作片段，以及不能同时运行的那些。 通俗的可以理解为,并发是我们写的代码，让两个任务同时执行，而是否真的并行是由系统决定的。 Queues 队列GCD 提供有 dispatch queues 来处理代码块，这些队列管理你提供给 GCD 的任务并用 FIFO (先进先出)顺序执行这些任务。这就保证了第一个被添加到队列里的任务会是队列中第一个开始的任务，而第二个被添加的任务将第二个开始，如此直到队列的终点。 所有的调度队列（dispatch queues）自身都是线程安全的，你能从多个线程并行的访问它们。 当你了解了调度队列如何为你自己代码的不同部分提供线程安全后，GCD的优点就是显而易见的。关于这一点的关键是选择正确类型的调度队列和正确的调度函数来提交你的工作。 调度队列主要是串行和并发,调度函数主要是同步和异步。选择合适的队列和合适的调度函数来实现自己特定的功能。 Serial Queues 串行队列串行队列中的任务一次执行一个，每个任务只在前一个任务完成时才开始。而且，你不知道在一个 Block 结束和下一个开始之间的时间长度，如下图所示： 这些任务的执行时机受到 GCD 的控制；唯一能确保的事情是 GCD 一次只执行一个任务，并且按照我们添加到队列的顺序来执行。 由于在串行队列中不会有两个任务并发运行，因此不会出现同时访问临界区的风险；相对于这些任务来说，这就从竞态条件下保护了临界区。所以如果访问临界区的唯一方式是通过提交到调度队列的任务，那么你就不需要担心临界区的安全问题了。 Concurrent Queues 并发队列在并发队列中的任务能得到的保证是它们会按照被添加的顺序开始执行，但这就是全部的保证了。任务可能以任意顺序完成，你不会知道何时开始运行下一个任务，或者任意时刻有多少 Block 在运行。再说一遍，这完全取决于 GCD 。 下图展示了一个示例任务执行计划，GCD 管理着四个并发任务： 注意 Block 1,2 和 3 都立马开始运行，一个接一个。在 Block 0 开始后，Block 1等待了好一会儿才开始。同样， Block 3 在 Block 2 之后才开始，但它先于 Block 2 完成。 何时开始一个 Block 完全取决于 GCD 。如果一个 Block 的执行时间与另一个重叠，也是由 GCD 来决定是否将其运行在另一个不同的核心上，如果那个核心可用，否则就用上下文切换的方式来执行不同的 Block 。 再次强调:并发队列只能保证,任务按照被添加的顺序开始执行。即只有开始顺序是确定的。 有趣的是， GCD 提供给你至少五个特定的队列，可根据队列类型选择使用。 GCD队列类型——Queue Types首先，系统提供给你一个叫做 主队列（main queue） 的特殊队列。和其它串行队列一样，这个队列中的任务一次只能执行一个。然而，它能保证所有的任务都在主线程执行，而主线程是唯一可用于更新 UI 的线程。这个队列就是用于发消息给 UIView 或发送通知的。 系统同时提供给你好几个并发队列。它们叫做 全局调度队列（Global Dispatch Queues）。目前的四个全局队列有着不同的优先级：background、low、default 以及 high。要知道，Apple 的 API 也会使用这些队列，所以你添加的任何任务都不会是这些队列中唯一的任务。 最后，你也可以创建自己的串行队列或并发队列。这就是说，至少有五个队列任你处置：主队列、四个全局调度队列，再加上任何你自己创建的队列。 GCD 的“艺术”归结为选择合适的队列来调度函数以提交你的工作。 参考链接 GCD源码 GCD 深入理解：第一部分]]></content>
      <tags>
        <tag>iOS 技术 GCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS10推送和通知新特性总结]]></title>
    <url>%2F2017%2F08%2F11%2FiOS10%E6%8E%A8%E9%80%81%E5%92%8C%E9%80%9A%E7%9F%A5%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言:此文章是对iOS10推送和通知新特性的一些总结，主要内容是一些需要注意的经验或技巧，对通知中具体的API没有进行很详细的介绍，所以阅读此文章需要先对iOS10的推送有一个基础的了解。 可以参考本文的参考链接，是两位大神对iOS10通知和推送进行的更详细的说明。 新framework针对推送和通知,iOS10引入了两个新的framework: UserNotifications.framework：用来注册和处理本地和远程通知,当通知到达用户的设备上时，Apps和app extensions 可以使用这个framework去接收和潜在的修改本地通知或远程通知。 UserNotificationsUI.framework：用来定制本地或远程通知出现在用户设备上时的外观。可以通过使用这个framework去定义一个app extension去接受通知的数据，然后提供一个与数据符合的可视化外观。当然这个app extension也能响应和这个通知结合的定制的响应动作。 新特性： 总体来说增加的新的实用的功能包括：撤回单条通知、更新已展示通知、中途修改通知内容、在通知中显示多媒体资源、自定义UI等。 iOS10以后，APNs可根据推送消息的唯一标示符查询某条消息是否被用户阅读，可更新某一推送消息，而不用发重读的多条消息。 推送字段说明： mutable-content:在推送中增加这个字段，决定了我们可以在service notification扩展中修改通知内容，也可以在content notification扩展中自定义通知界面。如果没有这个字段,我们新增的通知扩展不会生效。 category:是和后台商量好的一个值,不同的category可以显示不同的action,也就是通知下面的按钮或者输入框,可以扩展一些操作而不必进入程序。 apps-collapse-id:作为唯一标示，可以用来更新推送。 content-available:这个是在iOS7时引入的一个字段，如果开启了Background mode下的remote notification,并且推送的字段中包含此字段，只要用户不强制关掉App,App无论是在后台还是在前台，都可以回调下面的方法。- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(nonnull void (^)(UIBackgroundFetchResult))completionHandler 经验技巧（tips） 调用方法[[UIApplication sharedApplication] registerForRemoteNotifications];会触发调用下面两个方法之一- (void)application:(UIApplication )application didRegisterForRemoteNotificationsWithDeviceToken:(NSData )deviceToken- (void)application:(UIApplication )application didFailToRegisterForRemoteNotificationsWithError:(NSError )error也就是说，在真机环境下，哪怕用户还没有允许通知，或者设置了禁用推送，手机都是可以通过回调获取到deviceToken的。 iOS10中申请通知权限的代码如下: UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter]; center.delegate = self; // [center setNotificationCategories:nil]; [center getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) { if (settings.authorizationStatus == UNAuthorizationStatusNotDetermined) { [center requestAuthorizationWithOptions:(UNAuthorizationOptionBadge | UNAuthorizationOptionSound | UNAuthorizationOptionAlert) completionHandler:^(BOOL granted, NSError * _Nullable error) { if (granted && !error) { NSLog(@"允许通知"); } else { NSLog(@"拒绝通知"); } }]; } }]; //在用户允许通知之后，在真机中会再次回调获取到deviceToken的代理方法。 iOS10之前，在（1）应用程序在前台时；（2）应用程序在后台，然后点击了推送进入应用程序时，两种情况下会回调方法- (void)application:(UIApplication )application didReceiveRemoteNotification:(NSDictionary )userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler{ //下面简称“方法1”}如果开启了后台推送模式,还会在第三种情况下（3）应用程序在后台时，调用此方法。 从iOS10开始,新增了两个通知中心的代理方法来处理通知 - (void)userNotificationCenter:(UNUserNotificationCenter )center willPresentNotification:(UNNotification )notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler { //下面简称“方法2” //此方法只有应用程序在前台时才会调用,通知展示之前调用 NSLog(@”应用程序在前台,即将展示推送”); completionHandler(UNNotificationPresentationOptionBadge | UNNotificationPresentationOptionSound | UNNotificationPresentationOptionAlert);}- (void)userNotificationCenter:(UNUserNotificationCenter )center didReceiveNotificationResponse:(UNNotificationResponse )response withCompletionHandler:(void(^)())completionHandler { //下面简称“方法3” //用户对通知进行响应之后调用,各种响应都会调用此方法，可以根据参数response来判断用户的响应方式,是点击了通知，点击了按钮还是输入了内容等 NSLog(@”用户响应”); completionHandler();}如果实现了上述两个新增方法，当推送到达之后，调用的方法情况会发生变化，如下： 应用程序在前台，会首先调用“方法1”,然后再调用方法2； 应用程序在后台，只调用“方法1”； 应用程序在后台，点击某一条推送，调用“方法3”； 应用程序在前台，点击某一条推送，调用“方法3”。 使用了iOS10的新增方法之后，要想在推送到达之前或者应用程序在后台时执行一段代码，比如修改推送内容再提示用户，需要在项目中使用应用程序扩展Notification Service Extension来实现。 如果在项目中使用了应用程序扩展Notification Service Extension，在调试的过程中，如果想要打断点调试扩展的代码，需要在Xcode中运行扩展，然后再选择项目，才可以。（后面要说的另外一个扩展Notification Content Extension也是一样的道理） iOS10的通知新特性可以让通知中包含附件,比如音频、图像或视频等内容,并且可以将其内容显示出来。使用本地通知时,可以在通知创建时,将附件加入即可。对于远程通知，则必须实现使用UNNotificationServiceExtension类通知服务扩展。 如果在项目中使用了应用程序扩展Notification Content Extension,如果想要看到效果，必须在扩展的info.plist文件中设置NSExtension-&gt;NSExtensionAttributes-&gt;UNNotificationExtensionCategory字段的内容，可以是字符串或者字符串数组，字符串代表的是categoryIdentifier，必须和通知内容中的categoryIdentifier保持一致才会有效果。 如果使用本地推送，触发器为位置信息时，一般使用CLRegion的子类CLCircularRegion类来定义位置信息。 附件类UNNotificationAttachment定义的options属性中的UNNotificationAttachmentOptionsThumbnailClippingRectKey,代表的是缩略图显示的图片范围。（这个键所对应的值是包含一个归一化的CGRect - 也就是说，一个单元的矩形，其值是在以1.0〜 0.0 ，表示要显示的原始图像的所述部分的字典。例如，原点为（0.25 ， 0.25）和大小为（0.5 ，0.5 ）定义了剪辑矩形，只显示图像的中心部分。使用CGRectCreateDictionaryRepresentation函数来创建字典的矩形。） 附件的路径并不一定需要时https的，只要打开Allow Arbitrary Loads后就可以使用http。 假如前面在Service Extension下载好了图片或者是视频，在自定义UI部分想要获取，就可以通过UNNotificationAttachment * attachment = notification.request.content.attachments.firstObject;查找附件来获取数据。但是必须注意，形成附件后，文件的实际存储被移到了pushStore的一个系统级别的缓存文件夹，此时需要调用NSURL在iOS8开始提供的两个方法来获取权限，提取数据。 startAccessingSecurityScopedResourcestopAccessingSecurityScopedResource [attachment.URL startAccessingSecurityScopedResource]; NSData * data = [NSData dataWithContentsOfFile:attachment.URL.path]; [attachment.URL stopAccessingSecurityScopedResource]; self.imageView.image = [UIImage imageWithData:data]; 参考链接 iOS10里的通知与推送 iOS10推送必看系列文章,总共四篇]]></content>
      <tags>
        <tag>iOS,推送,通知</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中制作Framework静态库]]></title>
    <url>%2F2017%2F08%2F07%2FiOS%E4%B8%AD%E5%88%B6%E4%BD%9CFramework%E9%9D%99%E6%80%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[前言iOS开发中我们经常需要用到各种库，比如开源库AFNetworking,静态库BaiduMapAPI_Base.framework（百度地图SDK）,还有系统动态库UIKit.framework等等，今天我们来学习一下相关知识并自己制作一个framework静态库。 基础知识库什么是库？ 库是程序代码的集合，是共享程序代码的一种方式。根据源代码的公开情况，库可以分为开源库和闭源库两种类型。 开源库：公开源代码，能看到具体实现，比如 SDWebImage 、 AFNetworking。 闭源库：不公开源代码，是经过编译后的二进制文件，看不到具体实现，主要分为静态库和动态库。 静态库和动态库1、静态库和静态库的存在形式 静态库：.a和.framework 动态库：.dylib(现在为.tbd)和.framework 2、静态库和动态库使用时的区别 静态库：链接时，静态库会被完整地复制到可执行文件中， 被多次使用就有多份冗余拷贝； 动态库：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存。 3、.a与.framework的区别 .a是纯二进制文件，.a文件不能单独使用，至少要有.h文件配合； .framework除了二进制文件外，还包含一些资源文件（头文件，plist等），由于自身包含了头文件，所以.framework可以单独使用。 制作framework静态库创建静态库工程新建一个项目，选择Cocoa Touch Framework将静态库命名为SONGTestLib（名字随便起），并填写其他必要信息新建完成之后，在PROJECT&gt;Info&gt;Deployment Target&gt;iOS Deployment Target选择你需要支持的最低系统版本，同样的操作在TARGETS中，General&gt;Deployment Info&gt;Deployment Target，选择需要支持的最低系统版本。 项目初始生成时会自动生成一个头文件SONGTestLib.h(工程名.h),创建其他相关代码文件并编写代码选择工程文件&gt;target&gt;Build Settings&gt;Linking&gt;Mach-O Type，设置为Static Library，因为系统默认创建的是动态库，需要设置此项才能生成静态库。选择工程文件&gt;target&gt;Build Phases&gt;Headers,将需要公开的头文件从Project中拖入Public。将需要公开的.h文件都用#import&lt;SONGTestLib/PublicHeader.h&gt;形式引入,记住一定要将所有的需要公开的.h文件都写在给定的.h文件中,不然编译后生成的.framework在引用的时候会有警告。 添加资源文件（可选）有时候我们的静态库中也需要图片素材、媒体文件、xib、storyboard等外部资源，此时我们可以通过bundle将这些资源文件一起打包到framework中。 外部资源不能直接打包到framework静态库中，必须将资源放到.bundle中。 bundle是静态的，也就是说，我们包含到包中的资源文件作为一个资源包是不参加项目编译的。也就意味着，bundle包中不能包含可执行的文件。它仅仅是作为资源，被解析成为特定的2进制数据。 创建.bundle方法一:第一种创建.bundle的方法很简单，直接新建一个文件夹，将文件夹添加后缀.bundle即可。 如果需要的外部资源中只包含图片素材或媒体文件,可以优先选择这种方式,当然也可以选择下面的方法二。 方法二:通过创建工程的方式创建.bundle。 新建一个项目,选择macOS&gt;Framework &amp; Library&gt;Bundle 给项目命名,并填写其他必要信息 在TARGETS&gt;Build Settings&gt;Deployment&gt;iOS Deployment Target&gt;选择自己需要支持的最低系统版本 Build后会生成一个bundle包，但在包中的图片由以前的png格式全部变成tiff格式。为了防止这种格式转变,需要在Build Settings&gt;Architectures&gt;Base SDK&gt;选择iOS的SDK要支持的版本。这时TARGETS中Build Settings&gt;User-Defined中会出现一个新的Key：COMBINE_HIDPI_IMAGES,把它设置为NO。 将需要的资源,如图片、storyboard、xib等文件添加到工程中。storyboard和xib文件可以直接从其他项目中拖过来，也可以在当前Bundle工程中创建;至于连线,不必拘泥于必须在同一个工程中的文件,即一个工程中的xib可以与另一个工程中的文件连线,只要类名相同即可。 上面所有的步骤完成之后,command+B编译项目,即可在Products中找到生成的bundle。 使用.bundle将.bundle添加到静态库工程中：直接将.bundle拖入到工程中即可。 注:如果.bundle中包含编译之后的xib、storyboard等文件,在framework中包含xib对应的类,在使用时可能会遇到类似Unknown class NewCell in Interface Builder file.或者[ setValue:forUndefinedKey:]: this class is not key value coding-compliant for the key myImageView.的报错,这是因为xib等文件中的使用的类名没有被链接到项目中。这里列举两种解决方法: 在任意一个代码文件中调用一下报错的类,例如[MyClass class];即可。 选择工程文件&gt;target&gt;Build Settings&gt;Linking&gt;Other Linker Flags，设置为-ObjC。 获取bundle中的资源 获取bundle路径NSString *bundlePath = [NSBundle mainBundle] pathForResource:@"NibBundle" ofType:@"bundle"] 获取bundleNSBundle *myBundle = [NSBundle bundleWithPath:bundlePath] 加载bundle中的某个nib[UINib nibWithNibName:@"NibCell" bundle:myBundle] 或者 [[myBundle loadNibNamed:@"NibCell" owner:self options:nil] lastObject]; 获取bundle中的图片UIImage *image = [UIImage imageNamed:[@"YourBundleName.bundle" stringByAppendingPathComponent:@"yourImageName.png"]]; 或者 UIImage *image = [UIImage imageWithContentsOfFile:[bundlePath stringByAppendingPathComponent:@"yourImageName.png"]]; 生成通用的静态库此时对工程进行编译已经可以生成静态库，但按照工程默认的设置，静态库并不是支持所有的架构。因为我们的静态库是给别人用的，所以一般会支持所有的架构，模拟器和真机的各种机型都要支持，所以还需要一定的工作来生成通用的静态库。 Debug和Release版本 一般来说, 我们应该发布的是release版本。 debug:调试版本, 系统本身也会有一些调试代码. 此版本体积会稍大, 运行会稍慢。 release: 发布版本, 系统会去除调试代码, 体积变小, 运行速度变快. 对用户来说没有明显的感觉。 导出Products静态库的配置在静态库工程中，如果配置中的Build Active Architecture Only设置为YES的话，导出的静态库只包含当前的架构。在默认配置中Targets&gt;Build Settings&gt;Build Active Architecture Only,Debug为YES,release为NO，我们要发布的也是release版本，所以要确保这一步没有修改。 修改Scheme:将Build Configuration为Release 分别导出模拟器和真机版本的静态库先选择Generic iOS Device，按下Command+B：Build一下 然后随意选择一个模拟器再次Build一下 找到Build后的framework我们看到总共有两个文件夹，Release-iphoneos文件夹中是真机编译生成的文件，Release-iphonesimulator文件夹中是模拟器编译生成的文件。 合并静态库的模拟器与真机架构 合并之后的动态/静态库要与原来的名称一致，不然用的时候编译会报错 合并的主要是是framework下的同名文件 我们将合并后的文件放到Products文件夹下,命令行为lipo -create /Users/songbo/Library/Developer/Xcode/DerivedData/SONGTestLib-dalamcasyjusbjcoiswoasefbbuq/Build/Products/Release-iphonesimulator/SONGTestLib.framework/SONGTestLib /Users/songbo/Library/Developer/Xcode/DerivedData/SONGTestLib-dalamcasyjusbjcoiswoasefbbuq/Build/Products/Release-iphoneos/SONGTestLib.framework/SONGTestLib -output /Users/songbo/Library/Developer/Xcode/DerivedData/SONGTestLib-dalamcasyjusbjcoiswoasefbbuq/Build/Products/SONGTestLib 这里解释一下这看似很复杂的命令：lipo -create +被合成的两个原来文件的路径 + -output + 合成后文件的输出路径 ，所以上面命令执行之后会在Products文件夹下生成合成之后的文件将合成之后的文件SONGTestLib替换掉之前Release-iphoneos中framework中的SONGTestLib,此时Release-iphoneos中framework即是我们合成之后可以使用的framework。 验证合并后的静态库架构验证静态库架构的代码为lipo -info + 静态库文件路径 例如验证我们上面制作的静态库架构 lipo -info /Users/songbo/Library/Developer/Xcode/DerivedData/SONGTestLib-dalamcasyjusbjcoiswoasefbbuq/Build/Products/Release-iphoneos/SONGTestLib.framework/SONGTestLib验证显示我们制作的静态库架构包括i386 armv7 x86_64 arm64，符合我们的要求。 至此，静态库制作完成。 使用静态库添加静态库将上文制作好的静态库直接拖入到需要使用静态库的项目中，注意将Copy items if needed打勾， 使用资源文件(可选,与制作静态库时对应)如果制作静态库时，在静态库中添加了.bundle形式的资源文件，此时如果资源文件是必须用的，还必须要将资源文件添加到当前的工程项目中： 方法：选中工程名，在右键菜单中选择Add Files to “工程名”…，从SONGTestLib.framework中选择SONGImages.bundle文件，并勾选“Copy items if needed”复选框，单击“Add”按钮，将资源文件添加到工程中。 注意事项如果静态库内有 category 分类，那么需要在添加 -ObjC 编译标识，否则可能会报：unrecognized selector sent to instance。 方法：选择工程文件&gt;target&gt;Build Settings&gt;Linking&gt;Other Linker Flags，设置为-ObjC 其他编译参数说明 1、－ObjC：加了这个参数后，链接器就会把静态库中所有的Objective-C类和分类都加载到最后的可执行文件中。 2、－all_load：会让链接器把所有找到的目标文件都加载到可执行文件中，但是千万不要随便使用这个参数！假如你使用了不止一个静态库文件，然后又使用了这个参数，那么你很有可能会遇到ld: duplicate symbol错误，因为不同的库文件里面可能会有相同的目标文件，所以建议在遇到-ObjC失效的情况下使用-force_load参数。 3、-force_load：所做的事情跟-all_load其实是一样的，但是-force_load需要指定要进行全部加载的库文件的路径，这样的话，你就只是完全加载了一个库文件，不影响其余库文件的按需加载。 参考资料 ios开发：Xcode8制作framework及使用 iOS 中静态链接库的使用 IOS开发中制作属于自己的静态库.a、资源库.bundle、.framework iOS中的静态库 .a 和 .framework &amp;&amp; 资源库.bundle iOS静态库 【.a 和framework】 xcode7制作framework,结合xib,storyboard,资源文件等 “Unknown class in Interface Builder file” error at runtime]]></content>
      <tags>
        <tag>iOS,技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[未来已来 - 打开新世界]]></title>
    <url>%2F2017%2F07%2F11%2F%E6%9C%AA%E6%9D%A5%E5%B7%B2%E6%9D%A5-%E6%89%93%E5%BC%80%E6%96%B0%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"><![CDATA[Hi,大家好，我是此刻柳暗花明，本名宋波，目前在做iOS开发。我希望自己会是一个实干家，因为我有很多梦想，我想看到它们开花结果。欢迎来到我的地盘，嘿嘿！😜 赠人玫瑰，手有余香。 最近抽时间搭建了真正属于自己的博客，今后我会在此分享学习心得，记录生活感受。如果能够在写作过程中帮助到一些人，或者为他们带去一些启发，我一定会非常开心。 每个人都会憧憬更加美好的未来，而未来从哪里来？从此刻来。好好的把握现在，认真的活在当下，一切希望都会水到渠成，我们都会此刻柳暗花明。 未来已来——未来由此刻创造，未来诞生于此刻。新世界已打开，我是此刻柳暗花明，祝你好运！]]></content>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
</search>